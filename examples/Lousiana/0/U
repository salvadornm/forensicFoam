/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Utop           (5.0 0.0 0.0);    // check python script
Uinit          (0.0 0.0 0.0);    // check python script


dimensions      [0 1 -1 0 0 0 0];

//internalField    uniform $Uinlet;


internalField   #codeStream
{
    codeInclude
    #{
	#include "fvCFD.H"
    #};

    codeOptions
    #{
	-I$(LIB_SRC)/finiteVolume/lnInclude \
	-I$(LIB_SRC)/meshTools/lnInclude
    #};
	
    codeLibs
    #{
	-lmeshTools \
	-lfiniteVolume
    #};
	
    code

    #{
	const IOdictionary& d = static_cast<const IOdictionary&>(dict);
	const fvMesh& mesh = refCast<const fvMesh>(d.db());

    vectorField U(mesh.nCells());
	const vectorField& CC = mesh.C(); //cell center 

    //------------------------------------------
    const scalar w1 = 1.0/800; const scalar Vrms= 0.01;
    const scalar Zref = 100.0;const scalar Vref = 5.0;

    // some fluctuations in velocity
	forAll(U,cellI)
	{
	    	const scalar x = CC[cellI].x();
	    	const scalar y = CC[cellI].y();
            const scalar z = CC[cellI].z(); 
            scalar zd = exp(-z/Zref);
            scalar up = Vref*min(pow(z/Zref, 2),1);          
            scalar vp = 0.0; //check random
            for (int i=1;i <8; i++)
            {              
              vp +=  Vrms*sin(i*w1*y + 0.25*i)*sin(x/200)/i;
            }
           
	        U[cellI] = vector(up,vp*zd,0.0);
	}
	writeEntry(os,"", U);
    #};
};


boundaryField
{
    
    top
    {
      type            fixedValue;
      value           uniform $Utop;
      //  type           zeroGradient;  
       // type slip;
    }

    wall
    {
        type            noSlip;
    }

    bottom
    {
        type            noSlip;
    }

   "(north|south|east)"
    {
        type           zeroGradient;      
    }

//     west2
//     {

//     // Mandatory entries (unmodifiable)
//     type            atmBoundaryLayerInletVelocity;
//     value           uniform (0 0 0);

//     // // Mandatory (inherited) entries (runtime modifiable)
//     flowDir         (1 0 0);
//     zDir            (0 0 1);
//     Uref            2.57222;
//     Zref            9.1;
//     z0              uniform 0.5;
//     zGround         uniform 0.0;

//     // // Optional (inherited) entries (unmodifiable)
//     kappa           0.41;
//     Cmu             0.09;
//     initABL         true;
//     phi             phi;
//     C1              0.0;
//     C2              1.0;


//    // contanst inlet TEST
//     type            fixedValue;
//     value           uniform $Uinlet;

//     }

   west
   {
        type           fixedValue;
        value          #codeStream
        {

        codeInclude
        #{
	        #include "fvCFD.H"
        #};

        codeOptions
        #{
	        -I$(LIB_SRC)/finiteVolume/lnInclude \
	        -I$(LIB_SRC)/meshTools/lnInclude
        #};
	
        codeLibs
        #{
	        -lmeshTools \
	        -lfiniteVolume
        #};
	
        code
        #{
            // access boundary mesh information (always the same)
            const IOdictionary& d = static_cast<const IOdictionary&>
            (
            dict.parent().parent()
            );
            const fvMesh& mesh = refCast<const fvMesh>(d.db());
            const label id = mesh.boundary().findPatchID("west");
            const fvPatch& patch = mesh.boundary()[id];
            vectorField U(patch.size(), vector(0, 0, 0));
            ////-------
            const scalar Zref = 100.0;const scalar Vref = 5.0;
            forAll(U, i)
            {
            const scalar z = patch.Cf()[i][2];  
            scalar up = Vref*min(pow(z/Zref, 2),1);              
            U[i] = vector(up,0.0,0.0);
            } 
            ////--------
            writeEntry(os,"", U);
        #};

        };
   }     
}
// ************************************************************************* //
