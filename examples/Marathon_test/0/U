/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Utop           (4.879639249161253 0.0 0.0);    // check python script
Uinit          (0.0 0.0 0.0);    // check python script


dimensions      [0 1 -1 0 0 0 0];

//internalField    uniform $Uinit;
internalField   #codeStream
{
    codeInclude
    #{
	#include "fvCFD.H"
    #};

    codeOptions
    #{
	-I$(LIB_SRC)/finiteVolume/lnInclude \
	-I$(LIB_SRC)/meshTools/lnInclude
    #};
	
    codeLibs
    #{
	-lmeshTools \
	-lfiniteVolume
    #};
	
    code

    #{
	const IOdictionary& d = static_cast<const IOdictionary&>(dict);
	const fvMesh& mesh = refCast<const fvMesh>(d.db());

    vectorField U(mesh.nCells());
	const vectorField& CC = mesh.C(); //cell center 

    //------------------------------------------------- //
    // -----      DATA FROM FILE                    ----//
    const scalar Vref = 3.138471; scalar windangle = 239.349330;

    //------------------------------------------------- //
    // ABL:  zg ground  z0 roughness zmax (height where ABL exist)    
    // V(Zref)= Vref Zref: refernce height

    const scalar zmax  = 500; const scalar Zref = 100.0;  
    const scalar zg = 0; const scalar z0 = 0.5; const scalar kappa =0.41;
    const scalar Ustar =  kappa*Vref/log((Zref+z0)/z0);
    //const scalar deg2rad = 0.5*3.141592/90;
    const scalar pi=Foam::constant::mathematical::pi;
    const scalar deg2rad = 0.5*pi/90;
    
    windangle = windangle*deg2rad;


    // pertubation data
    const scalar w1 = 1.0/800; const scalar Vrms= 0.3;
    // array of phase
    int nmodes = 8; scalar phis[nmodes];
    for (int i=0;i <nmodes; i++) { phis[i] = rand()*pi;}


    // ******** ///

    // some fluctuations in velocity, perpendicular direction to wind
	forAll(U,cellI)
	{
	    	const scalar x = CC[cellI].x();
	    	const scalar y = CC[cellI].y();
            const scalar z = CC[cellI].z(); 
            const scalar zd = exp(-z/Zref);            
            scalar zbl = min(z,zmax) - zg + z0;
            
            scalar Uwind = Ustar*log(zbl/z0)/kappa;
            scalar up = Uwind*sin(windangle);
            scalar vp = Uwind*cos(windangle);            
            scalar xi = x*cos(windangle) + y*sin(windangle); 
            scalar wp = 0.0; 
            for (int i=1;i <=nmodes; i++)
            {              
              wp +=  Vrms*sin(i*w1*xi + phis[i-1])/i;
            }           
	     U[cellI] = vector(up,vp,wp*zd);        
	}
	writeEntry(os,"", U);
    #};
};


boundaryField
{
    
    top
    {
      type slip;
      //type           zeroGradient;
    }

    "(bottom|terrain)"
    {
        type            noSlip;       
    }

    containment2
    {
       type            fixedValue;
       value           uniform (0 0 0.2473)       
    }	    

    tank2
    {
       type            fixedValue;
       value           uniform (0 0 1.7144);
    }

    tank111
    {
       type            fixedValue;
       value           uniform (0 0 0.1876);
    }
///
   containment
    {
        type            uniformFixedValue;
        uniformValue    coded;
        name            area1;    
        code 
        #{                                
            vector Unit,Umax;
	        const scalar Vpeak = 0.2473;
            const scalar t0 = 6.5*3600;      // 6:30    start sim
            const scalar t1 = 2*3600  + t0;  // 8:30    end of growth
            const scalar t2 = 5*3600  + t0;  // 13:30   start decay
            const scalar t3 = 17*3600 + t0;  // 23:30   end
            const scalar a = 1/((t1-t0)*(t1-t0));
            const scalar b = 1/((t3-t2)*(t3-t2));
                    
            Unit[0] = 1.0;Unit[1]=1.0;Unit[2]=1.0;   
            Umax[0] = 0.0;Umax[1]=0.0;Umax[2]=Vpeak; 

          return vector
       (
           min(Unit*a*(x-t0)*(x-t0),Umax) - Umax*max(x-t2,0)*b*(x-t2) 
       );

        #};
    } 
///
    tank1
    {
        type            uniformFixedValue;
        uniformValue    coded;
        name            tankfire;    
        code 
        #{                                
            vector Unit,Umax;
	        const scalar Vpeak =  0.41855; //<-------------------------
            const scalar t0 = 6.5*3600;    // 6:30    start sim
            const scalar ts = 8.5*3600;    // 8:30    start tank fire
            const scalar t1 = 10.5*3600;   // 10:30   end growth phase
            const scalar t2 = 13.5*3600;   // 13:30   star decay
            const scalar t3 = 23.5*3600;   // 23:30   end
            
            const scalar a = 1/((t1-ts)*(t1-ts));
            const scalar b = 1/((t3-t2)*(t3-t2));
            const scalar small = 0.00001;
                    
            Unit[0] = 1.0;Unit[1]=1.0;Unit[2]=1.0;   
            Umax[0] = 0.0;Umax[1]=0.0;Umax[2]=Vpeak; 

          return vector
       (
         max(x-ts+small,0)/(x-ts) * (min(Unit*a*(x-ts)*(x-ts),Umax)  - Umax*max(x-t2,0)*b*(x-t2) ) 
       );

        #};
    } 
///
    tank2
    {
        type            uniformFixedValue;
        uniformValue    coded;
        name            tankfire2;    
        code 
        #{                                
            vector Unit,Umax;
	        const scalar Vpeak =  3.80144; //<-------------------------
            const scalar t0 = 6.5*3600;    // 6:30    start sim
            const scalar ts = 8.5*3600 + 300;  // 8:35    start tank2 fire
            const scalar t1 = 10.5*3600;   // 10:30   end growth phase
            const scalar t2 = 13.5*3600;   // 13:30   star decay
            const scalar t3 = 23.5*3600;   // 23:30   end
            
            const scalar a = 1/((t1-ts)*(t1-ts));
            const scalar b = 1/((t3-t2)*(t3-t2));
            const scalar small = 0.00001;
                    
            Unit[0] = 1.0;Unit[1]=1.0;Unit[2]=1.0;   
            Umax[0] = 0.0;Umax[1]=0.0;Umax[2]=Vpeak; 

          return vector
       (
         max(x-ts+small,0)/(x-ts) * (min(Unit*a*(x-ts)*(x-ts),Umax)  - Umax*max(x-t2,0)*b*(x-t2) ) 
       );

        #};
    } 
///


   "(east|west)"
    {
        type           zeroGradient;      
    }

   "(north|south)"
    {
        type            zeroGradient;      
    }

}
// ************************************************************************* //
