/*--------------------------------*- C++ -*----------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Version:  10
     \\/     M anipulation  |
\*---------------------------------------------------------------------------*/
FoamFile
{
    format      ascii;
    class       volVectorField;
    location    "0";
    object      U;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Utop           (4.879639249161253 0.0 0.0);    // check python script
Uinit          (0.0 0.0 0.0);    // check python script


dimensions      [0 1 -1 0 0 0 0];

//internalField    uniform $Uinlet;


internalField   #codeStream
{
    codeInclude
    #{
	#include "fvCFD.H"
    #};

    codeOptions
    #{
	-I$(LIB_SRC)/finiteVolume/lnInclude \
	-I$(LIB_SRC)/meshTools/lnInclude
    #};
	
    codeLibs
    #{
	-lmeshTools \
	-lfiniteVolume
    #};
	
    code

    #{
	const IOdictionary& d = static_cast<const IOdictionary&>(dict);
	const fvMesh& mesh = refCast<const fvMesh>(d.db());

    vectorField U(mesh.nCells());
	const vectorField& CC = mesh.C(); //cell center 

    //------------------------------------------------- //
    // -----      DATA FROM FILE                    ----//
    const scalar Vref = 3.124100; scalar windangle = 140.194430;

    //------------------------------------------------- //
    // ABL:  zg ground  z0 roughness zmax (height where ABL exist)    
    // V(Zref)= Vref Zref: refernce height

    const scalar zmax  = 500; const scalar Zref = 100.0;  
    const scalar zg = 0; const scalar z0 = 0.5; const scalar kappa =0.41;
    const scalar Ustar =  kappa*Vref/log((Zref+z0)/z0);
    //const scalar deg2rad = 0.5*3.141592/90;
    const scalar pi=Foam::constant::mathematical::pi;
    const scalar deg2rad = 0.5*pi/90;
    
    windangle = windangle*deg2rad;


    // pertubation data
    const scalar w1 = 1.0/800; const scalar Vrms= 0.3;
    // array of phase
    int nmodes = 8; scalar phis[nmodes];
    for (int i=0;i <nmodes; i++) { phis[i] = rand()*pi;}


    // ******** ///

    // some fluctuations in velocity, perpendicular direction to wind
	forAll(U,cellI)
	{
	    	const scalar x = CC[cellI].x();
	    	const scalar y = CC[cellI].y();
            const scalar z = CC[cellI].z(); 
            const scalar zd = exp(-z/Zref);            
            scalar zbl = min(z,zmax) - zg + z0;
            
            scalar Uwind = Ustar*log(zbl/z0)/kappa;
            scalar up = Uwind*sin(windangle);
            scalar vp = Uwind*cos(windangle);            
            scalar xi = x*cos(windangle) + y*sin(windangle); 
            scalar wp = 0.0; 
            for (int i=1;i <=nmodes; i++)
            {              
              wp +=  Vrms*sin(i*w1*xi + phis[i-1])/i;
            }
           
	     U[cellI] = vector(up,vp,wp*zd);
            //U[cellI] = vector(0.0,0.0,0.0);
            
	}
	writeEntry(os,"", U);
    #};
};


boundaryField
{
    
    top
    {
     // type            fixedValue;
    //  value           uniform $Utop;
    //  type           zeroGradient;  
      type slip;
    }

    "(bottom|terrain)"
    {
        type            noSlip;
    }

    tank1
    {
     type            noSlip;
     //  type            flowRateInletVelocity;
     //  volumetricFlowRate    constant  0.00026; //default 0.00026 m3/s
     //  value           uniform (0 0 0);

     //  type            fixedValue;
     //  value           uniform (0 0 5.0);
    }



   "(east|west)"
    {
        type           zeroGradient;      
    }

   "(north|south)"
    {
        type            zeroGradient;      
    }


//    west
//    {
//         type           fixedValue;
//         value          #codeStream
//         {

//         codeInclude
//         #{
// 	        #include "fvCFD.H"
//         #};

//         codeOptions
//         #{
// 	        -I$(LIB_SRC)/finiteVolume/lnInclude \
// 	        -I$(LIB_SRC)/meshTools/lnInclude
//         #};
	
//         codeLibs
//         #{
// 	        -lmeshTools \
// 	        -lfiniteVolume
//         #};
	
//         code
//         #{
//             // access boundary mesh information (always the same)
//             const IOdictionary& d = static_cast<const IOdictionary&>
//             (
//             dict.parent().parent()
//             );
//             const fvMesh& mesh = refCast<const fvMesh>(d.db());
//             const label id = mesh.boundary().findPatchID("west");
//             const fvPatch& patch = mesh.boundary()[id];
//             vectorField U(patch.size(), vector(0, 0, 0));
//             ////------- ABL
//             const scalar Vref = 3.12; const scalar windangle = 90;//DATA
//             const scalar zmax  = 500;
//             const scalar zg = 0; const scalar z0 = 0.5; const scalar kappa =0.41;
//             const scalar Zref = 100.0;  
//             const scalar Ustar =  kappa*Vref/log((Zref+z0)/z0);                
//             ///-------

//             forAll(U, i)
//             {
//             const scalar z = patch.Cf()[i][2];  
//             const scalar zbl = min(z,zmax) - zg + z0;
//             //scalar up = Vref*min(pow(z/Zref, 2),1); 
//             scalar up = Ustar*log(zbl/z0)/kappa;             

//             U[i] = vector(up,0.0,0.0);
//             } 
//             ////--------
//             writeEntry(os,"", U);
//         #};

//         };
//    }     
}
// ************************************************************************* //
